import { Buffer } from 'buffer';
export interface Voice {
    Name: string;
    ShortName: string;
    Gender: string;
    Locale: string;
    FriendlyName: string;
    LocalName: string;
}
export interface SynthesisOptions {
    pitch?: string | number;
    rate?: string | number;
    volume?: string | number;
    outputFormat?: string;
}
export interface WordBoundary {
    type: "WordBoundary";
    offset: number;
    duration: number;
    text: string;
}
export declare class EdgeTTS {
    private audio_stream;
    private audio_format;
    private output_format;
    private word_boundaries;
    private ws;
    normalizeVoices(data: any[]): Promise<Voice[]>;
    getVoices(): Promise<Voice[]>;
    getVoicesByLanguage(locale: string): Promise<Voice[]>;
    getVoicesByGender(gender: 'Male' | 'Female'): Promise<Voice[]>;
    private generateUUID;
    private validatePitch;
    private validateRate;
    private validateVolume;
    synthesize(text: string, voice?: string, options?: SynthesisOptions): Promise<void>;
    private escapeXML;
    private getSSML;
    private nowRFC1123;
    private parseRFC1123;
    private buildTTSConfigMessage;
    synthesizeStream(text: string, voice?: string, options?: SynthesisOptions): AsyncGenerator<Uint8Array, void, unknown>;
    private processAudioData;
    private parseMetadata;
    generateSecMsGec: (trustedClientToken: string) => Promise<string>;
    getDuration(): number;
    private getFileExtension;
    getAudioInfo(): {
        size: number;
        format: string;
        estimatedDuration: number;
    };
    toFile(outputPath: string, format?: string): Promise<string>;
    toRaw(): string;
    toBase64(): string;
    toBuffer(): Buffer;
    saveMetadata(outputPath: string): Promise<void>;
    getWordBoundaries(): WordBoundary[];
}
